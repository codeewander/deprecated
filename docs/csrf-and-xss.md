---
id: csrf-and-xss
title: Web 前端資安風險 - CSRF 和 XSS
keywords:
  - CSRF
  - XSS
  - Web Security
---

常見的 Web 前端安全漏洞像是：`XSS` 和 `CSRF`

## 1. XSS(跨站指令攻擊)

跨站指令攻擊(Cross-site Script)，原本縮寫應該是 CSS，為和 CSS 樣式表因此調整縮寫為 XSS，指的是透過網頁開發留下的漏洞，注入惡意程式碼到網頁，使使用者加載並執行惡意的程式碼，攻擊`瀏覽器`，可能造成使用者 cookie 被竊取，甚至結合瀏覽器漏洞對使用者瀏覽器進行遠程遙控。

### 攻擊方式

XSS 攻擊可以分成三種：`反射型(非持久)`、`儲存型(持久型)` 和 `DOM 型`，其危害：儲存型 > 反射型 > DOM 型

#### 1. 反射型

瀏覽器發請求時，XSS 程式碼出現在 url 中，並提交至伺服器，伺服器回傳 response 時可能會額外回傳其他內容，例如密碼等機密資訊，為一次性。

例如：使用者發送獲取訂單列表的請求，黑客插入惡意程式碼，導致伺服器回傳時多回傳了使用者的帳號密碼。

#### 2. 儲存型

具有攻擊性的程式碼被保存到伺服器端(資料庫)，並且可以被其他使用者取得，永久性儲存。

例如：使用者發送保存評論的請求，黑客插入惡意程式碼將評論者資訊也紀錄在資料庫，這時候，網路上其他使用者可以看到評論者的個資。

#### 3. DOM 型

基於 DOM 檔案物件模型的漏洞，透過 DOM 動態修改頁面內容，從使用者端獲取 DOM 中的數據

例如：伺服器回傳 response 時，黑客插入惡意程式，導致原本網頁上的 Logo 被換掉

### 防禦方式

防禦方式可分為三種：

#### 1. 輸入過濾

將用戶輸入的內容進行過濾和驗證，包括對 URL、查詢關鍵字、Post 數據等，僅接受指定長度範圍內、適當格式且符合預期字符的內容提交(使用者端和伺服器端都要)

#### 2. 輸出轉譯

例如：在 HTML 標籤之間插入不可信任的數據時，要對其做 HTML Entity 編碼

#### 3. 使用 HttpOnlyCookie

將 cookie 標記為 httponly，這樣瀏覽器向伺服器發請求時就會帶 cookie，但 JS 程式碼無法取得此 cookie，如此就避免利用 JS 的 document.cookie 取得 cookie

## 2. CSRF(跨站請求偽造)

跨站請求偽造（Cross-site request forgery），又被稱為 one-click 攻擊 或者 session riding，指的是偽造請求(通常會是一個連結)，誘使使用者點擊，一旦點擊之後，就可以欺騙瀏覽器、讓網站以為是使用者本人的操作。

例如：使用者在網站 A 透過登入了銀行系統，此時帳號密碼已存在瀏覽器的 cookie 中，這時，同時打開惡意網站 B 的某連結，該連結是一個偽造請求，在使用者為登入的狀態下，點擊該連結就發送了自己不知道的請求到 A 網站。

簡單來說，攻擊成功要滿足兩個條件：

1. 該網站沒有進行防止 CSRF 處理，導致請求容易被偽造
2. 使用者要在登入狀態下點擊惡意連結

### 防禦方式

#### 1. 請求參數增加 token 並驗證

此種方式比第一種安全，是常見的作法。透過每次請求參數加上一個隨機碼(token)，而伺服器每次對這個隨機碼進行驗證。

#### 2. 訪問控制安全管理

- 驗證 HTTP Referer，判斷請求來源是否合法

Referer 紀錄了該 HTTP 請求的來源地址。然而，此種方式有缺點，就是 Referer 存在偽造的風險，若瀏覽器設定發送請求不提供 Referer 時，網站會拒絕合法使用者的訪問

- 機密資訊的修改使用 post 而不是 get 方法

- 機密資訊的修改要對其身份進行二次驗證
  例如：修改帳號時，需要輸入舊密碼

#### 3. 安全的登入管理

- 不要在使用者端儲存機密資訊(像是在 cookie 儲存帳號密碼)
- 一定時間內無操作則自動登出
- 關閉瀏覽器時自動登出

## XSS V.S. CSRF

CSRF 借著使用者權限完成攻擊，但攻擊者並沒有拿到用戶的權限 ; 而 XSS 直接盜取了使用者的權限，然後進行操作或破壞

參考資料：
[讓我們來談談 CSRF](https://blog.techbridge.cc/2017/02/25/csrf-introduction/)
